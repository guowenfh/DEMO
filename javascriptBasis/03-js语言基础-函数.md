[TOC]

## 函数 

> 函数式一块javascript代码，定义一次，可以被多次调用与执行，JS中的函数也是对象，所以JS函数可以像其他对象那样操作，和传递，所以也称函数对象
> 函数的参数列表相当于函数的人口，`return`相当于函数的出口，函数本身就是一种数据类型，函数是可以嵌套定义的。

### 函数基础

####　定义函数的方式

有三种方式可以定义函数。并且有着如下区别：

| 定义方式： | `function` 语句（函数声明） | `Function` 构造函数 | 函数表达式|
|----|---|----|------|
| 解析时机： | 优先解析(声明前置) | 顺序解析 | 顺序解析(声明提前，赋值不提前) |
| 允许匿名： | 有名 | 匿名 | 匿名|
| 形式： | 句子 |表达式 | 表达式 |
| 性质： | 静态 | 动态 | 静态|
| 作用域： | 具有函数的作用域 | 顶级函数(顶级作用域)| 具有函数作用域 |

主要有下面两个需要注意的地方：

- 理解`Function` 构造函数的顶级作用域，直接看代码就好：很直观就可以表示出来

```js
var a = 1;
function test() {
    var a  = 2;
    var func = new Function("console.info(a)");
    func();
}
test();//1;
```

- 函数表达式的多种创建方式：

```js
// 最简单的形式，将函数赋值给一个变量
var add = function(a,b){
    //do ..
}
// 立即执行匿名函数表达式IIFE
(function() {
    //do ..
})();
// 将函数当成返回值
return function(){
    //do ..
}
//命名式函数表达式NFE
var add  = function foo(a,b){
    // do..
    // 只在foo函数内部可以使用foo这个名称(用途如：递归调用)（在新版浏览器下可用）
    // 外部访问不到foo这个函数名
}
```


#### 函数的参数

> 在JS中函数的参数分为形式参数和实际参数两个概念

```js
function test(a,b,c,d) {
    console.log(test.length)//4
    return a+b+c;
}
console.info(test(10,20,30))//60
console.log(test.length)//4
console.log(arguments.length);//3,表示实际接受的参数个数
console.log(arguments[0]);//10，传进来的第一个参数===a
```

在 **函数内部** ，JS使用了一个特别的变量`arguments`的 **类数组对象**（以后再来说这个问题），用来接受传入函数的实际参数列表。

```js
function arg(a,b,c){
    arguments[0] = 1;
    console.info(a,b,c)
}
arg(143,456,6)//1 456 6
```
普通模式下可以直接对于`arguments`对象进行更改，上面的代码就是一个很直观的例子，我们直接更改了第一个参数的值，**但建议不要去试图更改`arguments`对象的属性**，不符合规范。
注：严格模式下`arguments`对象是实参的一个副本，所以上面的改动不会生效(自行尝试)


### 构造函数

什么是构造函数？



#### 理解 `Javascript`中的`this`

基于不同的调用方式this的指向也会有所不同，调用方式大致有如下几种：

|调用方式 |  表达式|
|----|----|
|直接调用 |  `foo();`|
|对象方法 |  `o.method();`|
|构造器 |  `new Foo();`|
|call／apply／bind |  `func.call(o)`|

为什么这些调用方式的this指向会有所不同呢？请记住一句话:
**this对象是在运行时基于执行环境所绑定的**

下面一个小例子可以很好的帮助理解这句话：

```js
var k = 10;

function test() {
    this.k = 20;
}
alert(test.k);//undefined
test();
alert(test.k);//undefined
alert(k);//20
```

可以看到这个地方，`test()`这个函数实际上是在`window`下被调用的，它实际上是`window.test()`的简写，所以`this.k`中的`this`实际上是指向的`window`。，所以在最后才会打印出20。（this总是指向调用者）


#### 使用 `call`与 `apply`， `bind`手动改变this

最先来看看ES5引入的`bind`，它最简单的用法是来显式的设置this指向。如：
```js
var x = 9;
var module = {
    x :81,
    getX : function(){
        return this.x;
    }
};
console.info(module.getX());//81
var getX = module.getX;
console.info(getX());//9

var boundGetX = getX.bind(module);
console.info(boundGetX());//81
```

下面再来看看`apply`与`call`，所有的函数都有这两个方法，它们所实现的功 能也是相同的，只不过在进行传递参数的时候有所不同。

- 简单用法：绑定一些函数用于传递参数，调用

```js
function sum(a, b) {
    return a + b;
}
function call1(num1, num2) {
    return sum.call(this, num1, num2);
}
function apply1(num1, num2) {
    // return sum.apply(this,[num1,num2])
    return sum.apply(this, arguments);//利用函数的arguments对象

}
alert(call1(10, 20));//30
alert(call1(5, 10));//15
```
可以看到我们在后两个函数中，可以直接使用sum方法。

- 扩充作用域

我们直接看例子：

```js
var color = 'red';
var obj = {color:'blue'}
function showColor(){
    alert(this.color);
}
showColor()//red
showColor.call(obj)//blue
showColor.apply(obj)//blue
```

使用`call()`、`aplly()`来扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。



