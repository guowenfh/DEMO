
## 函数`Function`

> 函数的参数列表相当于函数的人口，`return`相当于函数的出口，函数本身就是一种数据类型，函数是可以嵌套定义的。

###　定义函数的方式

有三种方式可以定义函数。并且有着如下区别：

| 定义方式 | `function` 语句 | `Function` 构造函数 | 函数直接量|
|----|---|----|------|
| 形式 | 句子 |表达式 | 表达式 |
| 名称 | 有名 | 匿名 | 匿名|
| 性质 | 静态 | 动态 | 静态|
| 解析时机 | 优先解析 | 顺序解析 | 顺序解析 |
| 作用域 | 具有函数的作用域 | 顶级函数(顶级作用域)| 具有函数作用域 |

一般来说直接使用 `function`语句会是一个更好的选择

### 函数的参数

> 在JS中函数的参数分为形式参数和实际参数两个概念


```js
function test(a, b,c,d) {
    console.log(test.length)//4
    return a+b+c;
}
console.info(test(10,20,30))//60
```

在 **函数内部** ，JS使用了一个特别的变量`arguments`的类数组对象，用来接受传入函数的实际参数列表。
例如在上面的函数内部增加如下代码：

```js
console.log(test.length)//4
console.log(arguments.length);//3,表示实际接受的参数个数
console.log(arguments[0]);//10，传进来的第一个参数===a
```

**递归实现阶乘**

```js
function fact(num) {
    if (num < 1) {
        return 1;
    } else {
        return fact(num - 1) * num;
    }
}
console.log(fact(5)) //120
```

### 理解 `Javascript`中的`this`

> this对象是在运行时基于执行环境所绑定的

下面一个小例子可以很好的帮助理解这句话：

```js
var k = 10;

function test() {
    this.k = 20;
}
alert(test.k);//undefined
test();
alert(test.k);//undefined
alert(k);//10
```
可以看到这个地方，`test()`这个函数实际上是在`window`下被调用的，它实际上是`window.test()`的简写，所以`this.k`中的`this`实际上是指向的`window`。，所以在最后才会打印出20。（this总是指向调用者）


### 使用 `call`与 `apply`

所有的函数都有这两个方法，它们所实现的功 能也是相同的，只不过在进行传递参数的时候有所不同。

- 简单用法：绑定一些函数用于传递参数，调用

```js
function sum(a, b) {
    return a + b;
}
function call1(num1, num2) {
    return sum.call(this, num1, num2);
}
function apply1(num1, num2) {
    // return sum.apply(this,[num1,num2])
    return sum.apply(this, arguments);//利用函数的arguments对象

}
alert(call1(10, 20));//30
alert(call1(5, 10));//15
```
可以看到我们在后两个函数中，直接使用sum函数的求和方法。


- 扩充作用域

我们直接看例子：

```js
var color = 'red';
var obj = {color:'blue'}
function showColor(){
    alert(this.color);
}
showColor()//red
showColor.call(obj)//blue
showColor.apply(obj)//blue
```
使用`call()`、`aplly()`来扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。

 
